app.jsx

import { useState } from "react";
import "./App.css";

function App() {
  const [username, setUsername] = useState("");
  const [password, setPassword] = useState("");
  const [token, setToken] = useState("");

  // Update this to your real backend URL + port
  const API_URL = "http://127.0.0.1:8000/api/token/";

  function handleLogin(e) {
    e.preventDefault();
    fetch(API_URL, {
      method: "POST",
      headers: { "Content-Type": "application/json" },
      body: JSON.stringify({ username, password }),
    })
      .then((res) => res.json())
      .then((data) => {
        if (data.access) {
          setToken(data.access);
          alert("Success!");
        } else {
          alert("Login failed: " + (data.detail || "Error"));
        }
      })
      .catch(() => alert("Could not connect to server. Is Django running?"));
  }

  function handleLogout() {
    setToken("");
    setUsername("");
    setPassword("");
  }

  return (
    <div className="login-card">
      <h1>Login</h1>

      {token === "" ? (
        <form onSubmit={handleLogin}>
          <input
            placeholder="Username"
            value={username}
            onChange={(e) => setUsername(e.target.value)}
            required
          />
          <input
            type="password"
            placeholder="Password"
            value={password}
            onChange={(e) => setPassword(e.target.value)}
            required
          />
          <button type="submit" className="login-btn">Login</button>
        </form>
      ) : (
        <div>
          <p style={{ color: "green", fontWeight: "bold" }}>‚úÖ Logged In</p>
          <p className="token-text">{token}</p>
          <button onClick={handleLogout} className="logout-btn">
            Logout
          </button>
        </div>
      )}
    </div>
  );
}

export default App;

url.pyfrom django.urls import path
from rest_framework_simplejwt.views import TokenObtainPairView
from authentication.views import protected_view

urlpatterns = [
    path('api/token/', TokenObtainPairView.as_view(), name='token_obtain_pair'),
    path('api/protected/', protected_view, name='protected_view'),
]

settings.py
"""
Django settings for myproject project.

Generated by 'django-admin startproject' using Django 5.2.8.

For more information on this file, see
https://docs.djangoproject.com/en/5.2/topics/settings/

For the full list of settings and their values, see
https://docs.djangoproject.com/en/5.2/ref/settings/
"""

from pathlib import Path

# Build paths inside the project like this: BASE_DIR / 'subdir'.
BASE_DIR = Path(__file__).resolve().parent.parent


# Quick-start development settings - unsuitable for production
# See https://docs.djangoproject.com/en/5.2/howto/deployment/checklist/

# SECURITY WARNING: keep the secret key used in production secret!
SECRET_KEY = 'django-insecure-r%!92mxeb36e@+5z73qj!)4v)ky)_wyofzw(vsc_2_w*_907sf'

# SECURITY WARNING: don't run with debug turned on in production!
DEBUG = True

ALLOWED_HOSTS = []

# Application definition

INSTALLED_APPS = [
    'django.contrib.admin',
    'django.contrib.auth',
    'django.contrib.contenttypes',
    'django.contrib.sessions',
    'django.contrib.messages',
    'django.contrib.staticfiles',
    'rest_framework',     
    'rest_framework_simplejwt', 
    'corsheaders',          
    'authentication',      
]

MIDDLEWARE = [
    'corsheaders.middleware.CorsMiddleware', 
    'django.middleware.security.SecurityMiddleware',
    'django.contrib.sessions.middleware.SessionMiddleware',
    'django.middleware.common.CommonMiddleware',
    'django.middleware.csrf.CsrfViewMiddleware',
    'django.contrib.auth.middleware.AuthenticationMiddleware',
    'django.contrib.messages.middleware.MessageMiddleware',
    'django.middleware.clickjacking.XFrameOptionsMiddleware',
]

CORS_ALLOW_ALL_ORIGINS = True 
CORS_ALLOW_CREDENTIALS = True
ROOT_URLCONF = 'myproject.urls'

CORS_ALLOWED_ORIGINS = ["http://localhost:5173", "http://127.0.0.1:5173"]

TEMPLATES = [
    {
        'BACKEND': 'django.template.backends.django.DjangoTemplates',
        'DIRS': [],
        'APP_DIRS': True,
        'OPTIONS': {
            'context_processors': [
                'django.template.context_processors.request',
                'django.contrib.auth.context_processors.auth',
                'django.contrib.messages.context_processors.messages',
            ],
        },
    },
]

WSGI_APPLICATION = 'myproject.wsgi.application'


# Database
# https://docs.djangoproject.com/en/5.2/ref/settings/#databases

DATABASES = {
    'default': {
        'ENGINE': 'django.db.backends.sqlite3',
        'NAME': BASE_DIR / 'db.sqlite3',
    }
}

# REST FRAMEWORK SETTINGS
REST_FRAMEWORK = {
    'DEFAULT_AUTHENTICATION_CLASSES': (
        'rest_framework_simplejwt.authentication.JWTAuthentication',
    ),
    'DEFAULT_PERMISSION_CLASSES': [
        'rest_framework.permissions.IsAuthenticated',
    ],
}

from datetime import timedelta
SIMPLE_JWT = {
    'ACCESS_TOKEN_LIFETIME': timedelta(minutes=60),
    'SLIDING_TOKEN_REFRESH_LIFETIME': timedelta(days=1),
    'AUTH_HEADER_TYPES': ('Bearer',),
}


# Password validation
# https://docs.djangoproject.com/en/5.2/ref/settings/#auth-password-validators

AUTH_PASSWORD_VALIDATORS = [
    {
        'NAME': 'django.contrib.auth.password_validation.UserAttributeSimilarityValidator',
    },
    {
        'NAME': 'django.contrib.auth.password_validation.MinimumLengthValidator',
    },
    {
        'NAME': 'django.contrib.auth.password_validation.CommonPasswordValidator',
    },
    {
        'NAME': 'django.contrib.auth.password_validation.NumericPasswordValidator',
    },
]


# Internationalization
# https://docs.djangoproject.com/en/5.2/topics/i18n/

LANGUAGE_CODE = 'en-us'

TIME_ZONE = 'UTC'

USE_I18N = True

USE_TZ = True


# Static files (CSS, JavaScript, Images)
# https://docs.djangoproject.com/en/5.2/howto/static-files/

STATIC_URL = 'static/'

# Default primary key field type
# https://docs.djangoproject.com/en/5.2/ref/settings/#default-auto-field

DEFAULT_AUTO_FIELD = 'django.db.models.BigAutoField'

views.py

from rest_framework.decorators import api_view, permission_classes
from rest_framework.permissions import IsAuthenticated
from rest_framework.response import Response

@api_view(['GET'])
@permission_classes([IsAuthenticated])
def protected_view(request):
    return Response({"message": f"Hello {request.user.username}!"})






========================================================================================













app.jsx
import { useState, useEffect } from "react";
// 1. ADD useNavigate TO YOUR IMPORTS
import { BrowserRouter as Router, Routes, Route, Link, Navigate, useNavigate } from "react-router-dom";
import "./App.css";

// ... (Home, Contact, Products components remain the same)

function AppContent() { // Move logic to a sub-component so useNavigate works
  const [username, setUsername] = useState("");
  const [password, setPassword] = useState("");
  const [token, setToken] = useState("");
  const [isRegistering, setIsRegistering] = useState(false);

  // 2. INITIALIZE THE NAVIGATE FUNCTION
  const navigate = useNavigate();

  const handleAuth = (e) => {
    e.preventDefault();
    const url = isRegistering ? "http://127.0.0.1" : "http://127.0.0.1";

    fetch(url, {
      method: "POST",
      headers: { "Content-Type": "application/json" },
      body: JSON.stringify({ username, password }),
    })
      .then((res) => res.json())
      .then((data) => {
        if (!isRegistering && data.access) {
          setToken(data.access);
          // 3. FORCE REDIRECT TO HOME IMMEDIATELY
          navigate("/"); 
        } else if (isRegistering && data.message) {
          alert("Success! Please login.");
          setIsRegistering(false);
        } else {
          alert("Error: " + (data.detail || "Action failed"));
        }
      });
  };

  return (
    <div className="App">
      {token && (
        <nav className="navbar">
          <div className="logo">MyBrand</div>
          <div className="nav-links">
            <Link to="/">Home</Link>
            <Link to="/products">Products</Link>
            <Link to="/contact">Contact</Link>
            <button onClick={() => { setToken(""); navigate("/login"); }} className="logout-btn">Logout</button>
          </div>
        </nav>
      )}

      <Routes>
        <Route path="/login" element={
            token ? <Navigate replace to="/" /> : (
              <div className="login-card">
                <h1>{isRegistering ? "Register" : "Login"}</h1>
                <form onSubmit={handleAuth}>
                  <input placeholder="Username" value={username} onChange={(e) => setUsername(e.target.value)} required />
                  <input type="password" placeholder="Password" value={password} onChange={(e) => setPassword(e.target.value)} required />
                  <button type="submit" className="login-btn">Submit</button>
                </form>
                <p onClick={() => setIsRegistering(!isRegistering)} style={{cursor: 'pointer', color: 'blue'}}>
                  {isRegistering ? "Back to Login" : "New user? Register here"}
                </p>
              </div>
            )
        } />
        <Route path="/" element={token ? <Home /> : <Navigate replace to="/login" />} />
        <Route path="/products" element={token ? <Products /> : <Navigate replace to="/login" />} />
        <Route path="/contact" element={token ? <Contact /> : <Navigate replace to="/login" />} />
      </Routes>
    </div>
  );
}

// IMPORTANT: Wrap your content in <Router> at the top level
export default function App() {
  return (
    <Router>
      <AppContent />
    </Router>
  );
}

admin.py
from django.contrib import admin
from .models import Product

admin.site.register(Product)

apps.py
from django.apps import AppConfig

class AuthenticationConfig(AppConfig):
    default_auto_field = 'django.db.models.BigAutoField'
    name = 'authentication' 

modules.py 

from django.db import models

class Product(models.Model):
    name = models.CharField(max_length=200)
    description = models.TextField()
    price = models.DecimalField(max_digits=10, decimal_places=2)

    def __str__(self):
        return self.name


serializer.py 

from rest_framework import serializers
from .models import Product

class ProductSerializer(serializers.ModelSerializer):
    class Meta:
        model = Product
        fields = '__all__'

url.py

from django.urls import path
from rest_framework_simplejwt.views import TokenObtainPairView, TokenRefreshView
from .views import register_view, protected_view, product_list # Use the dot!

urlpatterns = [
    path('register/', register_view, name='register'),
    path('token/', TokenObtainPairView.as_view(), name='token_obtain_pair'),
    path('token/refresh/', TokenRefreshView.as_view(), name='token_refresh'),
    path('protected/', protected_view, name='protected'),
    path('products/', product_list, name='product-list'),
]

========================================================================================================================================
==========================================================================================================================================

1. The "Non-Negotiable" Core
You cannot skip these. Even with AI tools, you must understand the mechanics.

TypeScript: In 2025, writing plain JavaScript for professional projects will be rare. Companies expect you to know TypeScript (types, interfaces, generics) because it prevents bugs in large applications.
Modern JavaScript (ES6+): Deep understanding of Promises, Async/Await, Closures, and the Event Loop.
CSS Mastery: You should know Flexbox and Grid perfectly. Knowledge of modern CSS architecture (like Tailwind CSS) is currently highly demanded.
2. The Framework Ecosystem
You don't need to know every framework, but you need to be an expert in one major ecosystem (usually React).

React (High Demand): Still the king. You need to know Hooks (useEffect, useState, useMemo), Context API, and State Management (Redux Toolkit or Zustand).
The "Meta-Frameworks": Companies are moving away from plain "Create React App." They want developers who know Next.js (App Router) or Remix. These handle routing and server-side rendering for you.
(Alternative: Vue/Nuxt or Angular are also valid, but React/Next.js has the highest job volume).
3. The "Frontend Backend" (Full Stack Lite)
This is the biggest change for 2025. Frontend developers are expected to handle the "glue" code that connects to the backend.

API Integration: REST APIs vs. GraphQL.
Serverless & BaaS: Since you mentioned Supabase, this is perfect. Companies love developers who can set up Authentication, Database queries, and Edge Functions directly from the frontend layer.
Server Actions: In Next.js, frontend devs are now writing backend logic. Understanding basic server security (sanitizing inputs) is a plus.
4. Performance & Quality (Senior Mindset)
Juniors make it work; Seniors make it fast. To stand out, show you care about quality.

Testing: Knowledge of Jest or Vitest (Unit testing) and Playwright or Cypress (End-to-end testing).
Web Vitals: Understanding why an app feels "slow" (Largest Contentful Paint, Cumulative Layout Shift) and how to fix it.
Accessibility (a11y): Making apps usable for people with disabilities. This is becoming a legal requirement in many places, so companies value it highly.
5. AI Proficiency
You won't be replaced by AI, but you might be replaced by a developer who uses AI well.

Tools: Companies expect you to use tools like GitHub Copilot, ChatGPT, or Cursor to write code faster.
The Skill: The ability to prompt AI correctly, review the code it generates for bugs, and integrate it efficiently.
6. The Portfolio (Your Real Qualification)
For a fresher, your resume matters less than your GitHub.

Projects: Don't just build a "To-Do List." Build something that solves a real problem.
Example: A dashboard that fetches real data, handles loading states, uses authentication (Supabase), and is responsive on mobile.
Open Source: Contributing to open source (even fixing a small typo in documentation) shows you can read other people's code and use Git professionally.
Summary Checklist for a 2025 Grad:
Language: TypeScript (Expert).
Framework: React + Next.js (Expert).
Styling: Tailwind CSS (Proficient).
Backend: Supabase / Firebase / API handling (Proficient).
Tools: Git, GitHub, VS Code, AI Assistants.
Soft Skills: Communication (able to explain your code), Problem Solving.
My Advice: Since you already know about Supabase, try to build a "Full Stack Frontend" project using Next.js + Supabase. This combination covers 80% of the requirements on this list and makes you instantly hireable.


import { useState, useEffect, useRef } from "react";
import useWebSocket from "react-use-websocket";
import EmojiPicker from 'emoji-picker-react';
import axios from 'axios';
import "./App.css";

function App() {
  // --- STATES ---
  const [username, setUsername] = useState("");
  const [password, setPassword] = useState("");
  const [token, setToken] = useState(""); 
  const [isRegistering, setIsRegistering] = useState(false);
  const [message, setMessage] = useState("");
  const [chatHistory, setChatHistory] = useState([]);
  const [showEmoji, setShowEmoji] = useState(false);
  const fileInputRef = useRef(null);

  // --- WEBRTC REFS ---
  const [localStream, setLocalStream] = useState(null);
  const pc = useRef(null);
  const localVideoRef = useRef(null);
  const remoteVideoRef = useRef(null);
  const [callType, setCallType] = useState(null);

  const BACKEND_URL = "http://127.0.0.1:8000";
  const WS_URL = "ws://127.0.0.1:8000/ws/chat/";

  const { sendJsonMessage, lastJsonMessage } = useWebSocket(token ? WS_URL : null, {
    shouldReconnect: () => true,
  });

  // --- 1. LOAD HISTORY WHEN TOKEN EXISTS ---
  useEffect(() => {
    if (token) {
      axios.get(`${BACKEND_URL}/api/messages/`, { headers: { Authorization: `Bearer ${token}` } })
        .then(res => setChatHistory(res.data)).catch(err => console.error(err));
    }
  }, [token]);

  // --- 2. RESTORE TOKEN ON REFRESH ---
  useEffect(() => {
    const savedToken = localStorage.getItem("token");
    if (savedToken) {
      setToken(savedToken);
    }
  }, []);

  // --- 3. HANDLE INCOMING MESSAGES (PREVENT DUPLICATES) ---
  useEffect(() => {
    if (lastJsonMessage) {
      const { msg_type, offer, answer, candidate, username: sender, call_mode } = lastJsonMessage;

      if (msg_type === 'rtc_offer' && sender !== username) {
        if (window.confirm(`${sender} is ${call_mode} calling. Accept?`)) {
          startLocalStream(call_mode === 'video').then(async (success) => {
            if (success && pc.current) {
              setCallType(call_mode);
              await pc.current.setRemoteDescription(new RTCSessionDescription(offer));
              const ans = await pc.current.createAnswer();
              await pc.current.setLocalDescription(ans);
              sendJsonMessage({ msg_type: 'rtc_answer', answer: ans, username });
            }
          });
        }
      } else if (msg_type === 'rtc_answer' && sender !== username) {
        if (pc.current) pc.current.setRemoteDescription(new RTCSessionDescription(answer));
      } else if (msg_type === 'rtc_candidate' && sender !== username) {
        if (pc.current) pc.current.addIceCandidate(new RTCIceCandidate(candidate));
      } else if (!msg_type.startsWith('rtc_')) {
        // FIX: Only add message to history if the sender is NOT me (prevents duplicates)
        if (sender !== username) {
          setChatHistory(prev => [...prev, lastJsonMessage]);
        }
      }
    }
  }, [lastJsonMessage]);

  // --- CALLING LOGIC ---
  const startLocalStream = async (isVideo) => {
    try {
      const stream = await navigator.mediaDevices.getUserMedia({ video: isVideo, audio: true });
      setLocalStream(stream);
      if (localVideoRef.current) localVideoRef.current.srcObject = stream;
      pc.current = new RTCPeerConnection({ iceServers: [{ urls: "stun:stun.l.google.com:19302" }] });
      stream.getTracks().forEach(track => pc.current.addTrack(track, stream));
      pc.current.onicecandidate = (e) => e.candidate && sendJsonMessage({ msg_type: 'rtc_candidate', candidate: e.candidate, username });
      pc.current.ontrack = (e) => { if (remoteVideoRef.current) remoteVideoRef.current.srcObject = e.streams[0]; };
      return true;
    } catch (err) {
      alert("Hardware Error: Camera/Mic not found.");
      return false;
    }
  };

  const handleCall = async (mode) => {
    const success = await startLocalStream(mode === 'video');
    if (success && pc.current) {
      setCallType(mode);
      const offer = await pc.current.createOffer();
      await pc.current.setLocalDescription(offer);
      sendJsonMessage({ msg_type: 'rtc_offer', offer, username, call_mode: mode });
    }
  };

  // --- 4. SEND MESSAGE WITH OPTIMISTIC UI ---
  const handleSendMessage = () => {
    if (message.trim()) {
      // Create message object
      const msgObj = {
        message,
        username,
        msg_type: 'text',
        timestamp: new Date().toLocaleTimeString()
      };

      // Add to screen IMMEDIATELY
      setChatHistory(prev => [...prev, msgObj]);

      // Clear inputs
      setMessage("");
      setShowEmoji(false);

      // Send to server for others
      sendJsonMessage(msgObj);
    }
  };

  // --- 5. HANDLE FILE UPLOAD WITH INSTANT PREVIEW ---
  const handleFileUpload = async (e) => {
    const file = e.target.files[0];
    if (!file) return;
    
    // Create a temporary preview URL
    const localUrl = URL.createObjectURL(file);
    const type = file.type.split('/')[0];

    const msgObj = {
      username,
      msg_type: type === 'image' || type === 'video' ? type : 'file',
      media_url: localUrl, // Use local URL for instant view
      message: `Sent a ${type}`,
      timestamp: new Date().toLocaleTimeString()
    };

    // Add to screen IMMEDIATELY
    setChatHistory(prev => [...prev, msgObj]);

    // Upload to server in background
    const formData = new FormData();
    formData.append('file', file);
    try {
      const res = await axios.post(`${BACKEND_URL}/api/upload/`, formData, { headers: { 'Authorization': `Bearer ${token}` } });
      
      // Send the REAL server URL to others via WebSocket
      sendJsonMessage({ 
        username, 
        msg_type: type === 'image' || type === 'video' ? type : 'file', 
        media_url: res.data.file, 
        message: `Sent a ${type}` 
      });
    } catch (err) { 
      alert("Upload failed"); 
    }
  };

  // --- AUTHENTICATION ---
  const handleAuth = async (da) => {
    da.preventDefault();
    const path = isRegistering ? "/api/register/" : "/api/token/";
    try {
      const res = await fetch(`${BACKEND_URL}${path}`, { method: "POST", headers: { "Content-Type": "application/json" }, body: JSON.stringify({ username, password }) });
      const data = await res.json();
      if (res.ok) {
        if (isRegistering) {
          setIsRegistering(false);
        } else {
          setToken(data.access);
          localStorage.setItem("token", data.access); // SAVE TOKEN
        }
      } else {
        alert(data.error || "Failed");
      }
    } catch (err) { alert("Server Down"); }
  };

  // --- RENDER LOGIC ---
  const renderMessage = (msg) => {
    // FIX: Handle blob URLs (local previews) and server URLs
    const fullUrl = msg.media_url?.startsWith('blob:') || msg.media_url?.startsWith('http')
      ? msg.media_url
      : `${BACKEND_URL}${msg.media_url}`;

    if (msg.msg_type === 'image') return <img src={fullUrl} className="chat-media" alt="Sent media" />;
    if (msg.msg_type === 'video') return <video src={fullUrl} controls className="chat-media" />;
    if (msg.msg_type === 'audio') return <audio src={fullUrl} controls className="chat-media" />;
    if (msg.msg_type === 'file') return <a href={fullUrl} target="_blank" rel="noreferrer" className="chat-media download-link">Download File</a>;
    return msg.message;
  };

  if (token) {
    return (
      <div className="chat-container">
        {/* HEADER */}
        <div className="chat-header">
          <h2 className="chat-header-title">Global Chat</h2>
          <div className="call-actions">
            <span onClick={() => handleCall('audio')}>üìû</span>
            <span onClick={() => handleCall('video')}>üé•</span>
          </div>
        </div>

        {/* VIDEO OVERLAY */}
        {localStream && (
          <div className="video-overlay">
            <div className="video-row">
              {callType === 'video' && <video ref={localVideoRef} autoPlay muted className="local-video" />}
              <video ref={remoteVideoRef} autoPlay className="remote-video" />
            </div>
            <button onClick={() => window.location.reload()} className="end-call-btn">End Call</button>
          </div>
        )}

        {/* CHAT BOX */}
        <div className="chat-box">
          {chatHistory.map((msg, i) => (
            <div key={i} className={`message ${msg.username === username ? 'my-msg' : ''}`}>
              <strong>{msg.username}:</strong> {renderMessage(msg)}
              <div className="chat-time">{msg.timestamp}</div>
            </div>
          ))}
        </div>
        
        {/* EMOJI PICKER */}
        {showEmoji && (
          <div className="emoji-picker-container">
            <EmojiPicker onEmojiClick={(e) => setMessage(prev => prev + e.emoji)} />
          </div>
        )}

        {/* TOOLBAR */}
        <div className="chat-toolbar">
          <button onClick={() => setShowEmoji(!showEmoji)}>üòä</button>
          <button onClick={() => fileInputRef.current.click()}>üìÅ</button>
          <input type="file" ref={fileInputRef} onChange={handleFileUpload} hidden />
        </div>

        {/* INPUT ROW */}
        <div className="input-row">
          <input value={message} onChange={e => setMessage(e.target.value)} onKeyDown={e => e.key === 'Enter' && handleSendMessage()} placeholder="Type..." />
          <button onClick={handleSendMessage}>Send</button>
        </div>
        
        {/* LOGOUT */}
        <button onClick={() => { 
            setToken(""); 
            localStorage.removeItem("token"); // CLEAR TOKEN
        }} className="logout-btn">Logout</button>
      </div>
    );
  }

  // LOGIN / REGISTER PAGE
  return (
    <div className="login-card">
      <h1>{isRegistering ? "Register" : "Login"}</h1>
      <form onSubmit={handleAuth}>
        <input placeholder="Username" value={username} onChange={e => setUsername(e.target.value)} required />
        <input type="password" placeholder="Password" value={password} onChange={e => setPassword(e.target.value)} required />
        <button type="submit" className="login-btn">{isRegistering ? "Register" : "Login"}</button>
      </form>
      <p onClick={() => setIsRegistering(!isRegistering)} className="toggle-auth">
        {isRegistering ? "Back to Login" : "Register here"}
      </p>
    </div>
  );
}

export default App;




ngrok config add-authtoken 35VJfMDq21Il1YzkzNLFSZKxA3T_7VN7s7xDULzSzoocuYMgh

================================


